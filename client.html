<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>GStreamer WebRTC Client (Advanced + Blob Fix)</title>
  <style>
    body {
      font-family: sans-serif;
    }

    #remoteVideo {
      width: 640px;
      height: 360px;
      background: black;
    }
  </style>
</head>

<body>
  <h1>GStreamer WebRTC Test (Perfect Negotiation + m‑line fix + Blob handling)</h1>
  <video id="remoteVideo" autoplay playsinline controls></video>
  <div>
    <button id="startBtn">Start WebSocket</button>
    <p id="status"></p>
  </div>

  <script>
    const SIGNALING_URL = "ws://localhost:8765";
    const polite = true;            // this side yields on collision
    let pc;                         // RTCPeerConnection
    let ws;                         // WebSocket
    let makingOffer = false;        // are we in the process of creating an offer?
    let ignoreOffer = false;        // should we drop an incoming offer?
    let remoteVideo, statusElem;

    window.onload = () => {
      remoteVideo = document.getElementById("remoteVideo");
      statusElem = document.getElementById("status");
      document.getElementById("startBtn").onclick = startSignaling;
    };

    function log(msg) {
      console.log("[STATUS]", msg);
      statusElem.textContent = msg;
    }

    function startSignaling() {
      log("Connecting to signaling server…");
      ws = new WebSocket(SIGNALING_URL);

      ws.onopen = () => {
        log("WebSocket open. Creating PeerConnection…");
        createPeerConnection();
      };

      ws.onmessage = async (evt) => {
        // —— Blob‑to‑text logic ——
        let dataText;
        if (evt.data instanceof Blob) {
          dataText = await evt.data.text();
          console.log("[WS] Received Blob → text");
        } else {
          dataText = evt.data;
        }

        console.log("[WS] Raw message:", dataText);
        let msg;
        try {
          msg = JSON.parse(dataText);
        } catch (e) {
          console.error("[WS] Failed to parse JSON:", e, dataText);
          return;
        }

        // ———— SDP offer/answer handling ————
        if (msg.type === "offer" || msg.type === "answer") {
          const desc = new RTCSessionDescription(msg);
          const isOffer = msg.type === "offer";
          const collision = isOffer &&
            (makingOffer || (pc && pc.signalingState !== "stable"));

          ignoreOffer = !polite && collision;
          if (ignoreOffer) {
            console.warn("[WS] Collision – ignoring incoming offer");
            return;
          }

          try {
            log(`${msg.type.toUpperCase()} received; setting remote description…`);
            if (!pc) {
              console.log("[WS] Creating new RTCPeerConnection (inside offer)");
              createPeerConnection();
            }
            await pc.setRemoteDescription(desc);

            if (isOffer) {
              log("Creating ANSWER…");
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              ws.send(JSON.stringify(pc.localDescription));
              log("ANSWER sent.");
            }
          } catch (err) {
            console.error("[WS] SDP negotiation failed:", err);

            // **m‑line order mismatch:** rebuild
            if (err.message.includes("order of m-lines")) {
              console.warn("[WS] m‑line mismatch → recreating PeerConnection");
              cleanupPeerConnection();
              createPeerConnection();

              // retry the exchange
              try {
                await pc.setRemoteDescription(desc);
                if (isOffer) {
                  const answer2 = await pc.createAnswer();
                  await pc.setLocalDescription(answer2);
                  ws.send(JSON.stringify(pc.localDescription));
                  log("Re‑sent ANSWER after reset.");
                }
              } catch (err2) {
                console.error("[WS] Retry negotiation failed:", err2);
              }
            }
          }
        }

        // ———— ICE candidate handling ————
        else if (msg.type === "ice") {
          try {
            await pc.addIceCandidate(msg.candidate);
            console.log("[WS] Remote ICE added.");
          } catch (e) {
            console.warn("[WS] Failed to add remote ICE:", e);
          }
        }
      };

      ws.onclose = () => {
        log("WebSocket closed.");
        cleanupPeerConnection();
      };
      ws.onerror = (e) => {
        console.error("[WS] WebSocket error:", e);
        cleanupPeerConnection();
      };
    }

    function createPeerConnection() {
      const config = {
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          {
            urls: "turn:your.turn.host:3478?transport=udp",
            username: "USERNAME",
            credential: "PASSWORD"
          }
        ],
        bundlePolicy: "balanced",
        rtcpMuxPolicy: "require",
        iceCandidatePoolSize: 1
      };
      pc = new RTCPeerConnection(config);
      log("PeerConnection created.");

      // Perfect‐negotiation: only create an offer when needed
      pc.onnegotiationneeded = async () => {
        try {
          makingOffer = true;
          log("Negotiation needed → creating OFFER…");
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          ws.send(JSON.stringify(pc.localDescription));
          log("OFFER sent.");
        } catch (err) {
          console.error("[WS] Failed to create/send offer:", err);
        } finally {
          makingOffer = false;
        }
      };

      // send ICE
      pc.onicecandidate = ({ candidate }) => {
        if (candidate) {
          ws.send(JSON.stringify({
            type: "ice",
            sdpMid: candidate.sdpMid,
            sdpMLineIndex: candidate.sdpMLineIndex,
            candidate: candidate.candidate
          }));
        console.log("[WS] Local ICE sent.");
      }
    };

    // display remote
    pc.ontrack = ({ streams }) => {
      console.log("[WS] Remote track arrived.");
      remoteVideo.srcObject = streams[0];
      remoteVideo.play().catch(e => console.warn("[WS] Video play error:", e));
      log("Connected & streaming.");
    };

    pc.onconnectionstatechange = () => {
      console.log("[WS] Connection state:", pc.connectionState);
      if (pc.connectionState === "failed") {
        log("ICE failed; restarting ICE.");
        pc.restartIce();
      }
    };
        }

    function cleanupPeerConnection() {
      if (!pc) return;
      pc.onnegotiationneeded = null;
      pc.onicecandidate = null;
      pc.ontrack = null;
      pc.onconnectionstatechange = null;
      pc.close();
      pc = null;
      log("PeerConnection closed.");
    }
  </script>
</body>

</html>
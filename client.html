<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GStreamer WebRTC Client</title>
  <style>
    body { font-family: sans-serif; }
    #remoteVideo {
      width: 640px;
      height: 360px;
      background: black;
    }
  </style>
</head>
<body>
  <h1>GStreamer WebRTC Test</h1>
  <video id="remoteVideo" autoplay playsinline controls></video>
  <div>
    <button id="startBtn">Start WebSocket</button>
    <p id="status"></p>
  </div>

  <script>
    const signalingUrl = "ws://localhost:8765"; // signaling server URL

    let pc = null;         // RTCPeerConnection
    let ws = null;         // WebSocket
    let remoteVideo;       // HTMLVideoElement for showing stream
    let statusElem;        // Paragraph element for status messages
    let lastOfferSdp = ""; // Optionally, store last offer to ignore duplicates

    window.onload = () => {
      remoteVideo = document.getElementById("remoteVideo");
      statusElem = document.getElementById("status");
      document.getElementById("startBtn").onclick = startWebSocket;
    };

    function logStatus(message) {
      console.log(message);
      if (statusElem) {
        statusElem.innerText = message;
      }
    }

    function startWebSocket() {
      logStatus("Connecting to signaling server...");

      ws = new WebSocket(signalingUrl);
      ws.onopen = () => {
        logStatus("WebSocket connected. Waiting for offer...");
      };

      ws.onmessage = async (evt) => {
        // Convert Blob to text if needed:
        let dataText;
        if (evt.data instanceof Blob) {
          dataText = await evt.data.text();
        } else {
          dataText = evt.data;
        }
        let msg;
        try {
          msg = JSON.parse(dataText);
        } catch (e) {
          console.error("Failed to parse message:", e);
          return;
        }
        console.log("Received message:", msg);

        if (msg.type === "offer") {
          // If we already have a connection and the connection is not in "stable" state,
          // ignore duplicate offers.
          if (pc && pc.signalingState !== "stable") {
            console.warn("Offer received but connection is already negotiating. Ignoring duplicate offer.");
            return;
          }
          // Optionally, compare the offer SDP to lastOfferSdp to avoid duplicate processing.
          if (msg.sdp === lastOfferSdp) {
            console.warn("Duplicate offer received. Ignoring.");
            return;
          }
          lastOfferSdp = msg.sdp; // Save this offer SDP

          logStatus("Received offer from server (GStreamer).");

          // Create a new RTCPeerConnection (close previous if needed)
          if (pc) {
            pc.close();
          }
          createPeerConnection();

          const offerDesc = new RTCSessionDescription({
            type: "offer",
            sdp: msg.sdp
          });

          try {
            await pc.setRemoteDescription(offerDesc);
            logStatus("Remote description set. Creating answer...");

            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);

            const answerMsg = {
              type: "answer",
              sdp: answer.sdp
            };
            ws.send(JSON.stringify(answerMsg));
            logStatus("Sent answer back to server.");
          } catch (error) {
            console.error("Error during SDP negotiation:", error);
            logStatus("SDP negotiation error.");
          }
        } else if (msg.type === "ice") {
          console.log("Received ICE candidate from server:", msg);
          const candidate = new RTCIceCandidate({
            sdpMid: msg.sdpMid,
            sdpMLineIndex: msg.sdpMLineIndex,
            candidate: msg.candidate
          });
          try {
            await pc.addIceCandidate(candidate);
            console.log("Added remote ICE candidate:", candidate);
          } catch (err) {
            console.warn("Error adding remote ICE candidate", err);
          }
        }
      };

      ws.onclose = () => {
        logStatus("WebSocket closed.");
      };

      ws.onerror = (err) => {
        console.error("WebSocket error:", err);
      };
    }

    function createPeerConnection() {
      const config = {
        iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }]
      };

      pc = new RTCPeerConnection(config);

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          const msg = {
            type: "ice",
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            candidate: event.candidate.candidate,
          };
          ws.send(JSON.stringify(msg));
          console.log("Sent ICE candidate to server:", msg);
        }
      };

      pc.ontrack = (event) => {
        console.log("Received remote track:", event.streams[0]);
        remoteVideo.srcObject = event.streams[0];
        logStatus("Connected and streaming.");
      };

      pc.onconnectionstatechange = () => {
        console.log("Connection state changed to:", pc.connectionState);
      };
    }
  </script>
</body>
</html>

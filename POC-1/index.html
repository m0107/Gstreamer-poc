<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ONVIF Streamer Dashboard</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    #controls { margin-bottom: 20px; }
    select, button { padding: 5px 10px; margin-right: 10px; }
    .stream { margin-bottom: 20px; }
    video { border: 1px solid #ccc; width: 480px; height: 360px; background: #000; }
    .stream-header { display: flex; align-items: center; margin-bottom: 5px; }
    .stream-header span { margin-right: 10px; font-weight: bold; }
  </style>
</head>
<body>

  <h1>ONVIF Streamer Dashboard</h1>
  <div id="controls">
    <label for="cameraSelect">Choose camera:</label>
    <select id="cameraSelect"><option>Loading...</option></select>
    <button id="refreshBtn">Refresh Cameras</button>
    <button id="startBtn">Start Stream</button>
  </div>

  <div id="streamsContainer"></div>

  <script>
    // ðŸš¨ Make sure this matches your FastAPI host & port:
    const apiBase = 'http://localhost:8000';

    let cameras = [];
    const streams = {};  // stream_id â†’ { pc, ws, containerEl }

    async function loadCameras() {
      console.log('[UI] loadCameras()');
      const sel = document.getElementById('cameraSelect');
      sel.disabled = true;
      sel.innerHTML = '<option>Loading...</option>';

      try {
        const resp = await fetch(`${apiBase}/cameras`);
        console.log('[UI] fetch /cameras â†’', resp.status);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        cameras = await resp.json();
        console.log('[UI] cameras =', cameras);

        if (cameras.length) {
          sel.innerHTML = cameras.map((c,i) =>
            `<option value="${i}">${c.service_url.replace(/^https?:\/\//,'')}</option>`
          ).join('');
        } else {
          sel.innerHTML = '<option disabled>No cameras found</option>';
        }
      } catch (err) {
        console.error('[UI] loadCameras error:', err);
        sel.innerHTML = '<option disabled>Error loading</option>';
      }

      sel.disabled = false;
    }

    async function startStream() {
      console.log('[UI] startStream()');
      const idx = document.getElementById('cameraSelect').value;
      if (cameras.length === 0 || idx === '') {
        alert('No camera selected');
        return;
      }
      const service_url = cameras[idx].service_url;

      try {
        const resp = await fetch(`${apiBase}/streams`, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ service_url })
        });
        console.log('[UI] fetch /streams POST â†’', resp.status);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const { stream_id } = await resp.json();
        console.log('[UI] started stream_id=', stream_id);
        setupStreamUI(stream_id, service_url);
      } catch (err) {
        console.error('[UI] startStream error:', err);
        alert('Failed to start stream: ' + err.message);
      }
    }

    function setupStreamUI(stream_id, service_url) {
      console.log('[UI] setupStreamUI(', stream_id, ')');
      const container = document.createElement('div');
      container.className = 'stream';
      container.id = `stream-${stream_id}`;
      container.innerHTML = `
        <div class="stream-header">
          <span>${service_url}</span>
          <button id="stop-${stream_id}">Stop</button>
        </div>
        <video id="video-${stream_id}" autoplay playsinline></video>
      `;
      document.getElementById('streamsContainer').append(container);

      document.getElementById(`stop-${stream_id}`)
        .onclick = () => stopStream(stream_id);

      const pc = new RTCPeerConnection({
        iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }]
      });
      pc.onicecandidate = e => {
        if (e.candidate) {
          console.log(`[UI][${stream_id}] ICE candidate â†’`, e.candidate);
          ws.send(JSON.stringify({
            type: 'ice',
            sdpMLineIndex: e.candidate.sdpMLineIndex,
            candidate: e.candidate.candidate
          }));
        }
      };
      pc.ontrack = e => {
        console.log(`[UI][${stream_id}] ontrack â†’`, e.streams);
        document.getElementById(`video-${stream_id}`).srcObject = e.streams[0];
      };

      const wsUrl = apiBase.replace(/^http/, 'ws') + `/ws/${stream_id}`;
      console.log('[UI] opening WS â†’', wsUrl);
      const ws = new WebSocket(wsUrl);

      ws.onopen = () => console.log(`[UI][${stream_id}] WS open`);
      ws.onerror = err => console.error(`[UI][${stream_id}] WS error`, err);
      ws.onclose = () => console.log(`[UI][${stream_id}] WS closed`);

      ws.onmessage = async ev => {
        const msg = ev.data;
        console.log(`[UI][${stream_id}] WS message:`, msg);
        if (msg.startsWith('v=0')) {
          // SDP offer from server
          await pc.setRemoteDescription({ type:'offer', sdp: msg });
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          console.log(`[UI][${stream_id}] sending SDP answer`);
          ws.send(answer.sdp);
        } else {
          // ICE lines: "ICE:mlineIndex:candidate..."
          const iceMatch = msg.match(/^ICE:(\d+):(.*)$/);
          if (iceMatch) {
            const mline = parseInt(iceMatch[1]), cand = iceMatch[2];
            console.log(`[UI][${stream_id}] adding ICE candidate`, mline, cand);
            await pc.addIceCandidate({ sdpMLineIndex: mline, candidate: cand });
          }
        }
      };

      streams[stream_id] = { pc, ws, container };
    }

    async function stopStream(stream_id) {
      console.log('[UI] stopStream(', stream_id, ')');
      await fetch(`${apiBase}/streams/${stream_id}`, { method:'DELETE' });
      const { pc, ws, container } = streams[stream_id] || {};
      if (pc) pc.close();
      if (ws) ws.close();
      if (container) container.remove();
      delete streams[stream_id];
    }

    // Hook buttons
    document.getElementById('refreshBtn').onclick = loadCameras;
    document.getElementById('startBtn').onclick   = startStream;

    // Kick things off
    loadCameras();
  </script>
</body>
</html>